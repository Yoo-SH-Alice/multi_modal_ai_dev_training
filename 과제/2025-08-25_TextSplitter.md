

# TextSplitter
텍스트를 작은 단위로 나누는 청킹(Chunking) 또는 **텍스트 분할(Text Splitting)** 


### 기본 텍스트 분할
##### CharacterTextSplitter
특정 문자를 기준으로 텍스트를 나눈다. 가장 기본적인 방법으로 줄바꿈(\n\n)이나
마침표(.)와 같은 구분자를 사용하여 문자를 분할한다. 가장 단순하지만 텍스트의 의미적 구조를 고려하지 않아 비효율 적일 수 있다

##### RecursiveCharacterTextSplitter
여러개의 구분자를 순서대로 사용하여 텍스트를 나눈다. 예를 들어 먼저 \n\n 기준으로 나누고 청크가 너무크면 \n으로 다시 나누고, 그래도 크면 공백( )으로 나눈다. 이 방식은 문맥의 손실을 최소하면서 일정한 청크의 크기를 만들 수 있어 가장 널리 사용된다


### 의미 기반 및 토큰 기반 분할 
##### TokenTextSplitter
텍스트를 특정 토큰수(token count)를 기준으로 분할한다. LLM의 토큰을 지정해서 문서를 청킹할 수있다는 장덤이 있다. LLM이 사용하는 토크나이저(tokenizer)를 사용하기 때문에 모델이 이해하는 단위도 분할 할 수 있다

##### SemanticChunker
텍스트의 의미적 유사성을 기반으로 분할 하는 방법이다. 문장을 임베딩(embeding)으로 변환 후, 문장 간의 의미적 거리를 측정하여 유사한 의미를 가진 문장들을 하나의 청크로 묶는다. 이 방식은 문맥을 보존하는 데 효과적이지만 계산 비용이 많이 든다.



### 구조 기반 분할
##### CodeSplitter
다양한 프로그래밍 언어로 작성된 코드를 분할 할 수 있다.  주석, 함수, 클래스 등 코딩 언어의 문법 구조를 인식하여 논리적으로 분할한다.

##### MarkdownHeaderTextSplitter
마크다운 문서의 헤더(`#`, `##`, `###` 등)를 기준으로 텍스트를 분할한다. 이 방식은 문서의 계층적 구조를 보존하여 특정 섹션에 대한 질문에 더 정확한 답변을 제공할 수 있다.

##### HTMLHeaderTextSplitter
MarkdownHeaderTextSplitter 과 유사하게 HTML문서의 구조를 활용한다. HTML 문서의 헤더 태그(`<h1>`, `<h2>` 등)를 기준으로 분할 한다.

##### RecursiveJsonSplitter
JSON 데이터를 깊이 우선 탐색(depth-first traversal)하여 더 작은 JSON 청크(chunk)를 생성한다. 
기본적인 Json구조를 유지하려고 노력한다. 하지만 청크의 크기가 너무 커지면(예: `max_chunk_size`를 초과하면), 객체를 나누기 시작한다. 이때, 객체 내부의 큰 문자열 값은 나누지 않고 통째로 보존한다.


# LlamaParser로 PDF 테스트
- 클라우드네이티브1-2.pdf -> [[클라우드네이티브1-2]].md 변환 했을때 1페이지 마지막 부분에 문장이 끊긴 부분에 파싱과정에서 자동으로 문장을 추가한다.
- 인식하때 마다 bold적용 제목인식, 기호인식등 디테일적인 인식 결과가 차이가 날 수 있다.
- 그림은 잘 인식하지 못한다
- OCR을 옵션으로 지정해서 사용이 가능하다
- 테이블 부분을 인식할때 html테그가 추가되어 있다. 삭제하면 마크다운 문서에서 표로 보는게 가능하다
